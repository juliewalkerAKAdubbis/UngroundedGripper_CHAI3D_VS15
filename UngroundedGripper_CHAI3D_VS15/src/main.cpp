//==============================================================================
/*
\author    <http://www.chai3d.org>
\author    Francois Conti
\version   3.2.0 $Rev: 1925 $
*/
//==============================================================================

//------------------------------------------------------------------------------
#include "chai3d.h"
#include "hapticsThread.h"
#include "magtracker.h"
#include "gripperChaiDevice.h"
//------------------------------------------------------------------------------
#include <GLFW/glfw3.h>
//------------------------------------------------------------------------------
using namespace chai3d;
using namespace std;
//------------------------------------------------------------------------------



//==============================================================================
/*
DEMO:    22-chrome.cpp

This demonstration loads a 3D face by using the file loader
functionality of the cMesh class. A finger-proxy algorithm is used to
render the forces. Spherical mapping is then generated by loading a
texture.

In the main haptics loop function  "updateHaptics()" , the position
of the haptic device is retrieved at each simulation iteration.
The interaction forces are then computed and sent to the device.
Finally, a simple dynamics model is used to simulate the behavior
of the object.
*/
//==============================================================================


string resourceRoot;			// root resource path
								// convert to resource path
#define RESOURCE_PATH(p)    (char*)((resourceRoot+string(p)).c_str())


// DECLARED FUNCTIONS
void close(void);		// this function closes the application
void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height);
void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods);
void hapticThreadHandler(void);
void magTrackerThreadHandler(void);
void motorThreadHandler(void);

// Thread Setup
hapticsThread H;					// haptics thread object
cThread* haptics_thread;			// haptic and graphics update thread
//cThread* motor_thread;				// motor controller

gripper* G; // = new gripper();											// create a gripper instance

magTrackerThread MT(0);
cThread* magTracker_thread;			// magnetic tracker

int main(int argc, char* argv[])
{
	
	cout << "-----------------------------------" << endl;
	cout << "CHAI3D" << endl;
	cout << "Demo: 22-chrome" << endl;
	cout << "Copyright 2003-2016" << endl;
	cout << "-----------------------------------" << endl << endl << endl;
	cout << "Keyboard Options:" << endl << endl;
	cout << "[f] - Enable/Disable full screen mode" << endl;
	cout << "[g] - Gravity   (ON/OFF)" << endl;
	cout << "[q] - Exit application" << endl;
	cout << endl << endl;

	// parse first arg to try and locate resources
	resourceRoot = string(argv[0]).substr(0, string(argv[0]).find_last_of("/\\") + 1);
			
//	gripper* G = new gripper();											// create a gripper instance
	G = new gripper();
	if (!G->connect()) {
		cout << "Failed to connect to Gripper." << endl;
	}
	G->disableCtrl();
	if (G->calibrate()) {
		cout << "Gripper Calibrated" << endl;
	}
	else {
		cout << "Failed to Calibrate Gripper" << endl; 
	}

	H.pairWithGripper(G);												// pair with haptics thread
		
	// set up hapticsThread object and keyboard and window callbacks
	H.initialize();														// set up all chai3D and haptic tool stuff
	glfwSetKeyCallback(H.window, keyCallback);							// set key callback
	glfwSetWindowSizeCallback(H.window, windowSizeCallback);			// set resize callback

	#ifdef MAGTRACKER
	// magnetic tracker setup
	MT.initMagTracker();													// initialize magnetic tracker
	MT.pairWithHapticsThread(&H.chaiMagDevice);							// share the chaiMagDevice with the magTracker
	
	// start the magnetic tracking thread
	magTracker_thread = new cThread();
	magTracker_thread->start(magTrackerThreadHandler, CTHREAD_PRIORITY_GRAPHICS);
	#endif

	// create a thread which starts the main graphics and haptics rendering loop
	haptics_thread = new cThread();
	haptics_thread->start(hapticThreadHandler, CTHREAD_PRIORITY_HAPTICS);

	// start the motor thread (setup via gripper object during haptics_thread initialization)
	//motor_thread = new cThread();
	//motor_thread->start(motorThreadHandler, CTHREAD_PRIORITY_HAPTICS);



	// setup callback when application exits
	atexit(close);


	// main graphic loop
	while (!glfwWindowShouldClose(H.window))
	{
		glfwGetWindowSize(H.window, &H.width, &H.height);			// get width and height of window
		H.updateGraphics();			// render graphics
		glfwSwapBuffers(H.window);		// swap buffers				
		glfwPollEvents();			// process events
		//H.graphicRate.signal(1);			// signal frequency counter
	}


	// close window
	glfwDestroyWindow(H.window);

	// terminate GLFW library
	glfwTerminate();

	// exit
	return 0;
}



void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height)
{
	// update window size
	H.width = a_width;
	H.height = a_height;
}




void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods)
{
	double defaultStretch = 0.50; // [N] ?


	// filter calls that only include a key press
	if ((a_action != GLFW_PRESS) && (a_action != GLFW_REPEAT))
	{
		return;
	}

	// option - exit
	else if ((a_key == GLFW_KEY_ESCAPE) || (a_key == GLFW_KEY_Q))
	{
		glfwSetWindowShouldClose(a_window, GLFW_TRUE);
	}


	// option - enable/disable gravity
	else if (a_key == GLFW_KEY_G)
	{
		if (H.ODEWorld->getGravity().length() > 0.0)
		{
			H.ODEWorld->setGravity(cVector3d(0.0, 0.0, 0.0));
		}
		else
		{
			H.ODEWorld->setGravity(cVector3d(0.0, 0.0, -9.81));
		}
	}

	// option - toggle fullscreen
	else if (a_key == GLFW_KEY_F)
	{
		// toggle state variable
		H.fullscreen = !H.fullscreen;

		// get handle to monitor
		GLFWmonitor* monitor = glfwGetPrimaryMonitor();

		// get information about monitor
		const GLFWvidmode* mode = glfwGetVideoMode(monitor);

		// set fullscreen or window mode
		if (H.fullscreen)
		{
			glfwSetWindowMonitor(H.window, monitor, 0, 0, mode->width, mode->height, mode->refreshRate);
			glfwSwapInterval(H.swapInterval);
		}
		else
		{
			int w = 0.8 * mode->height;
			int h = 0.5 * mode->height;
			int x = 0.5 * (mode->width - w);
			int y = 0.5 * (mode->height - h);
			glfwSetWindowMonitor(H.window, NULL, x, y, w, h, mode->refreshRate);
			glfwSwapInterval(H.swapInterval);
		}
	}

	//  DIRECTION CUES
	else if (a_key == GLFW_KEY_K) {
		H.keyboardCues = true;
		H.m_fingerForce.set(0.0, 0.0, 0.0);
		H.m_thumbForce.set(0.0, 0.0, 0.0);
		cout << "Zero Position" << endl << endl;

	}
	else if (a_key == GLFW_KEY_M)		//down
	{
		H.m_fingerForce.set(0.0, 0.0, -defaultStretch);
		H.m_thumbForce.set(0.0, 0.0, -defaultStretch);
		cout << "DOWN" << endl;

	}
	else if (a_key == GLFW_KEY_I)		//up
	{
	//	H.m_fingerForce
		H.m_fingerForce.set(0.0, 0.0, defaultStretch);
		H.m_thumbForce.set(0.0, 0.0, defaultStretch);
		cout << "UP" << endl;

	}
	else if (a_key == GLFW_KEY_L)		//forward
	{
		H.m_fingerForce.set(-defaultStretch, 0.0, 0.0);
		H.m_thumbForce.set(-defaultStretch, 0.0, 0.0);
		cout << "FORWARD" << endl;

	}
	else if (a_key == GLFW_KEY_J)		//backward
	{
		H.m_fingerForce.set(defaultStretch, 0.0, 0.0);
		H.m_thumbForce.set(defaultStretch, 0.0, 0.0);
		cout << "BACK" << endl;

	}
	else if (a_key == GLFW_KEY_R) {
		H.m_fingerForce.set(0.0, 10, 0.0);
		H.m_thumbForce.set(0.0, 10, 0.0);
		cout << "GRIPPER FORCE" << endl;
	}
}


//------------------------------------------------------------------------------
void hapticThreadHandler() {
	H.m_worldLock.acquire();
	H.updateHaptics();
	H.m_worldLock.release();
}

void magTrackerThreadHandler() {
	MT.m_magTrackerLock.acquire();
	MT.run();
	MT.m_magTrackerLock.release();
}

void motorThreadHandler() {
	G->motorLoop();
}

void close(void)
{
	// stop the simulation
	H.simulationRunning = false;

	// wait for graphics and haptics loops to terminate
	while (!H.simulationFinished) { cSleepMs(100); }

	// close haptic device
	H.tool->stop();

	// delete resources
	delete haptics_thread;
	delete magTracker_thread;
	delete H.world;
	delete H.handler;
}



