//==============================================================================
/*
\author    <http://www.chai3d.org>
\author    Francois Conti
\version   3.2.0 $Rev: 1925 $
*/
//==============================================================================

//------------------------------------------------------------------------------
#include "chai3d.h"
#include "hapticsThread.h"
#include "magtracker.h"
#include "gripperChaiDevice.h"
//------------------------------------------------------------------------------
#include <GLFW/glfw3.h>
//------------------------------------------------------------------------------
using namespace chai3d;
using namespace std;
//------------------------------------------------------------------------------



//==============================================================================
/*
DEMO:    22-chrome.cpp

This demonstration loads a 3D face by using the file loader
functionality of the cMesh class. A finger-proxy algorithm is used to
render the forces. Spherical mapping is then generated by loading a
texture.

In the main haptics loop function  "updateHaptics()" , the position
of the haptic device is retrieved at each simulation iteration.
The interaction forces are then computed and sent to the device.
Finally, a simple dynamics model is used to simulate the behavior
of the object.
*/
//==============================================================================


string resourceRoot;			// root resource path
								// convert to resource path
#define RESOURCE_PATH(p)    (char*)((resourceRoot+string(p)).c_str())


// DECLARED FUNCTIONS
void close(void);		// this function closes the application
void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height);
void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods);
void hapticThreadHandler(void);
void magTrackerThreadHandler(void);

// Thread Setup
hapticsThread H;					// haptics thread object
cThread* haptics_thread;			// haptic and graphics update thread
cThread* motor_thread;				// motor controller

magTrackerThread MT(0);
cThread* magTracker_thread;			// magnetic tracker

int main(int argc, char* argv[])
{
	cout << endl;
	cout << "-----------------------------------" << endl;
	cout << "CHAI3D" << endl;
	cout << "Demo: 22-chrome" << endl;
	cout << "Copyright 2003-2016" << endl;
	cout << "-----------------------------------" << endl << endl << endl;
	cout << "Keyboard Options:" << endl << endl;
	cout << "[1] - Texture   (ON/OFF)" << endl;
	cout << "[2] - Wireframe (ON/OFF)" << endl;
	cout << "[3] - Normals   (ON/OFF)" << endl;
	cout << "[f] - Enable/Disable full screen mode" << endl;
	cout << "[m] - Enable/Disable vertical mirroring" << endl;
	cout << "[q] - Exit application" << endl;
	cout << endl << endl;

	// parse first arg to try and locate resources
	resourceRoot = string(argv[0]).substr(0, string(argv[0]).find_last_of("/\\") + 1);
			
	gripper* G = new gripper();															// create a gripper instance
	H.pairWithGripper(G);												// pair with haptics thread
		
	H.initialize();														// set up all chai3D and haptic tool stuff
	glfwSetKeyCallback(H.window, keyCallback);							// set key callback
	glfwSetWindowSizeCallback(H.window, windowSizeCallback);			// set resize callback

 
	MT.initialize();													// initialize magnetic tracker
	MT.pairWithHapticsThread(&H.chaiMagDevice);							// share the chaiMagDevice with the magTracker
	
	// start the magnetic tracking thread
	magTracker_thread = new cThread();
	magTracker_thread->start(magTrackerThreadHandler, CTHREAD_PRIORITY_GRAPHICS);

	// create a thread which starts the main graphics and haptics rendering loop
	haptics_thread = new cThread();
	haptics_thread->start(hapticThreadHandler, CTHREAD_PRIORITY_HAPTICS);

	// setup callback when application exits
	atexit(close);


	// main graphic loop
	while (!glfwWindowShouldClose(H.window))
	{
		glfwGetWindowSize(H.window, &H.width, &H.height);			// get width and height of window
		H.updateGraphics();			// render graphics
		glfwSwapBuffers(H.window);		// swap buffers				////////////////////// FIX: THROWS EXCEPTION /////////////////////////////////////
		glfwPollEvents();			// process events
		//H.graphicRate.signal(1);			// signal frequency counter
	}


	// close window
	glfwDestroyWindow(H.window);

	// terminate GLFW library
	glfwTerminate();

	// exit
	return 0;
}



void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height)
{
	// update window size
	H.width = a_width;
	H.height = a_height;
}




void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods)
{
	// filter calls that only include a key press
	if ((a_action != GLFW_PRESS) && (a_action != GLFW_REPEAT))
	{
		return;
	}

	// option - exit
	else if ((a_key == GLFW_KEY_ESCAPE) || (a_key == GLFW_KEY_Q))
	{
		glfwSetWindowShouldClose(a_window, GLFW_TRUE);
	}

	// option - show/hide texture
	else if (a_key == GLFW_KEY_1)
	{
		H.showTexture = !H.showTexture;
		H.object->setUseTexture(H.showTexture);
	}

	// option - wire/fill triangle mode
	else if (a_key == GLFW_KEY_2)
	{
		H.showWireMode = !H.showWireMode;
		H.object->setWireMode(H.showWireMode);
	}

	// option - show/hide normals
	else if (a_key == GLFW_KEY_3)
	{
		H.showNormals = !H.showNormals;
		cColorf color;
		color.setRed();
		H.object->setNormalsProperties(0.05, color);
		H.object->setShowNormals(H.showNormals);
	}

	// option - toggle fullscreen
	else if (a_key == GLFW_KEY_F)
	{
		// toggle state variable
		H.fullscreen = !H.fullscreen;

		// get handle to monitor
		GLFWmonitor* monitor = glfwGetPrimaryMonitor();

		// get information about monitor
		const GLFWvidmode* mode = glfwGetVideoMode(monitor);

		// set fullscreen or window mode
		if (H.fullscreen)
		{
			glfwSetWindowMonitor(H.window, monitor, 0, 0, mode->width, mode->height, mode->refreshRate);
			glfwSwapInterval(H.swapInterval);
		}
		else
		{
			int w = 0.8 * mode->height;
			int h = 0.5 * mode->height;
			int x = 0.5 * (mode->width - w);
			int y = 0.5 * (mode->height - h);
			glfwSetWindowMonitor(H.window, NULL, x, y, w, h, mode->refreshRate);
			glfwSwapInterval(H.swapInterval);
		}
	}

	// option - toggle vertical mirroring
	else if (a_key == GLFW_KEY_M)
	{
		H.mirroredDisplay = !H.mirroredDisplay;
		H.camera->setMirrorVertical(H.mirroredDisplay);
	}
}


//------------------------------------------------------------------------------
void hapticThreadHandler() {
	H.m_worldLock.acquire();
	H.updateHaptics();
	H.m_worldLock.release();
}

void magTrackerThreadHandler() {
	MT.m_magTrackerLock.acquire();
	MT.run();
	MT.m_magTrackerLock.release();
}

void close(void)
{
	// stop the simulation
	H.simulationRunning = false;

	// wait for graphics and haptics loops to terminate
	while (!H.simulationFinished) { cSleepMs(100); }

	// close haptic device
	H.tool->stop();

	// delete resources
	delete haptics_thread;
	delete H.world;
	delete H.handler;
}



